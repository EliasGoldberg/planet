// Generated by CoffeeScript 1.10.0
(function() {
  this.Face = (function() {
    function Face(v0, v1, v2, lvl) {
      this.v = [v0, v1, v2];
      this.b = [];
      this.centroid = this.getCentroid();
      this.children = [];
      this.level = lvl != null ? lvl : 0;
      this.divideDistance = v0.distance(v1) * 5;
      this.string = this.v[0] + "\n" + this.v[1] + "\n" + this.v[2];
    }

    Face.prototype.detail = function(pvm, camera, results, lvl) {
      var child, d, j, k, l, len, len1, len2, ref, ref1, ref2, results1, tranformedCentroid;
      if (results == null) {
        results = {
          remove: [],
          add: []
        };
      }
      if (lvl == null) {
        lvl = 1;
      }
      if (lvl === 1 && this.isBackFacing(camera, pvm)) {
        if (this.children.length === 4) {
          results.add.push(this);
          ref = this.children;
          for (j = 0, len = ref.length; j < len; j++) {
            child = ref[j];
            results.remove = results.remove.concat(child.getLeafFaces());
          }
          return this.children = [];
        }
      } else {
        tranformedCentroid = pvm.multiply(this.centroid);
        d = camera.distance(tranformedCentroid);
        if (d < this.divideDistance) {
          if (this.children.length === 0) {
            results.remove.push(this);
            return results.add = results.add.concat(this.tessellate(1, Vector.lerp));
          } else {
            ref1 = this.children;
            results1 = [];
            for (k = 0, len1 = ref1.length; k < len1; k++) {
              child = ref1[k];
              results1.push(child.detail(pvm, camera, results, lvl + 1));
            }
            return results1;
          }
        } else {
          if (this.children.length === 4) {
            results.add.push(this);
            ref2 = this.children;
            for (l = 0, len2 = ref2.length; l < len2; l++) {
              child = ref2[l];
              results.remove = results.remove.concat(child.getLeafFaces());
            }
            return this.children = [];
          }
        }
      }
    };

    Face.prototype.getLeafFaces = function() {
      var child, j, leaves, len, ref;
      leaves = [];
      if (this.children.length === 4) {
        ref = this.children;
        for (j = 0, len = ref.length; j < len; j++) {
          child = ref[j];
          leaves = leaves.concat(child.getLeafFaces());
        }
      } else {
        leaves.push(this);
      }
      return leaves;
    };

    Face.prototype.getCentroid = function() {
      return new Vector([(this.v[0].a[0] + this.v[1].a[0] + this.v[2].a[0]) / 3, (this.v[0].a[1] + this.v[1].a[1] + this.v[2].a[1]) / 3, (this.v[0].a[2] + this.v[1].a[2] + this.v[2].a[2]) / 3]);
    };

    Face.prototype.tessellate = function(subdivisions, midpointFunction) {
      var b0, b1, b2, f0, f1, f2, f3, m0, m1, m2;
      if (subdivisions === 0) {
        return [this];
      }
      if (midpointFunction == null) {
        midpointFunction = Vector.lerp;
      }
      m0 = midpointFunction(this.v[0], this.v[1], 0.5);
      b0 = Vector.nor(this.b[0], this.b[1]);
      m1 = midpointFunction(this.v[1], this.v[2], 0.5);
      b1 = Vector.nor(this.b[1], this.b[2]);
      m2 = midpointFunction(this.v[2], this.v[0], 0.5);
      b2 = Vector.nor(this.b[2], this.b[0]);
      f0 = new Face(this.v[0], m0, m2, this.level + 1);
      f0.setBarys([this.b[0], b0, b2]);
      f1 = new Face(m0, this.v[1], m1, this.level + 1);
      f1.setBarys([b0, this.b[1], b1]);
      f2 = new Face(m0, m1, m2, this.level + 1);
      f2.setBarys([b0, b1, b2]);
      f3 = new Face(m2, m1, this.v[2], this.level + 1);
      f3.setBarys([b2, b1, this.b[2]]);
      this.children = [f0, f1, f2, f3];
      return [].concat(f0.tessellate(subdivisions - 1, midpointFunction)).concat(f1.tessellate(subdivisions - 1, midpointFunction)).concat(f2.tessellate(subdivisions - 1, midpointFunction)).concat(f3.tessellate(subdivisions - 1, midpointFunction));
    };

    Face.prototype.getNormal = function(pvm) {
      var v1, v2;
      v1 = pvm.multiply(this.v[1]).minus(pvm.multiply(this.v[0]));
      v2 = pvm.multiply(this.v[2]).minus(pvm.multiply(this.v[0]));
      return v1.crossProduct(v2).normalize();
    };

    Face.prototype.isBackFacing = function(camera, pvm) {
      var cVec, dot, normal;
      normal = this.getNormal(pvm);
      cVec = new Vector([0, 0, 0]).minus(camera).normalize();
      dot = normal.dotProduct(cVec);
      return dot > 0;
    };

    Face.prototype.setBary = function(bary, i) {
      return this.b[i] = bary;
    };

    Face.prototype.setBarys = function(barys) {
      return this.b = barys;
    };

    Face.prototype.midpoint = function(a, b) {
      return [(a.a[0] + b.a[0]) / 2, (a.a[1] + b.a[1]) / 2, (a.a[2] + b.a[2]) / 2];
    };

    Face.prototype.toString = function() {
      return this.string;
    };

    return Face;

  })();

}).call(this);

//# sourceMappingURL=face.js.map
