// Generated by CoffeeScript 1.10.0
(function() {
  this.Model = (function() {
    function Model(gl, program, faces1) {
      var i, k, l, len, len1, ref, ref1, t, u;
      this.gl = gl;
      this.program = program;
      this.faces = faces1;
      this.vertexToIndexMap = {};
      this.faceToIndexLocationMap = {};
      this.vertexReferenceCounts = {};
      this.bufferByteCounts = {};
      this.vertices = [];
      this.indices = [];
      this.stride = 6;
      this.pointers = [
        {
          name: 'a_Position',
          dim: 3,
          offset: 0
        }, {
          name: 'a_Bary',
          dim: 3,
          offset: 3
        }
      ];
      this.uniforms = [];
      this.textures = [];
      this.modifiers = [];
      ref = this.uniforms;
      for (k = 0, len = ref.length; k < len; k++) {
        u = ref[k];
        this.program.setUniform(u.name, u.value);
      }
      ref1 = this.textures;
      for (i = l = 0, len1 = ref1.length; l < len1; i = ++l) {
        t = ref1[i];
        this.setupTexture(t.url, t.sampler, i);
      }
      this.addFaces(this.faces);
      this.buildModel();
    }

    Model.prototype.detail = function(pvm, camera) {
      var face, k, len, ref, results;
      results = {
        add: [],
        remove: []
      };
      ref = this.faces;
      for (k = 0, len = ref.length; k < len; k++) {
        face = ref[k];
        face.detail(pvm, camera, results);
      }
      if (results.remove.length > 0 || results.add.length > 0) {
        this.removeFaces(results.remove);
        this.addFaces(results.add);
        return this.buildModel();
      }
    };

    Model.prototype.addFaces = function(faces) {
      var bary, face, i, k, len, results1, vertex;
      results1 = [];
      for (k = 0, len = faces.length; k < len; k++) {
        face = faces[k];
        this.faceToIndexLocationMap[face.toString()] = this.indices.length;
        results1.push((function() {
          var l, results2;
          results2 = [];
          for (i = l = 0; l <= 2; i = ++l) {
            vertex = face.v[i];
            if (!this.vertexExists(vertex)) {
              bary = this.getBary(face, i);
              face.setBary(bary, i);
              this.vertices = this.vertices.concat(vertex.elements()).concat(bary);
              this.vertexReferenceCounts[vertex.toString()] = 1;
            } else {
              this.vertexReferenceCounts[vertex.toString()]++;
              bary = this.getBary(face, i);
              face.setBary(bary, i);
            }
            results2.push(this.addIndex(vertex));
          }
          return results2;
        }).call(this));
      }
      return results1;
    };

    Model.prototype.addIndex = function(v) {
      var index, isNew;
      isNew = !this.vertexExists(v);
      if (isNew) {
        this.vertexToIndexMap[v.toString()] = this.vertices.length / this.stride - 1;
      }
      index = this.vertexToIndexMap[v.toString()];
      return this.indices.push(index);
    };

    Model.prototype.removeFaces = function(faces) {
      var face, i, index, k, l, laterIndex, laterIndexIndices, laterIndexVtoIMap, len, len1, len2, location, m, otherFace, otherLocation, ref, ref1, ref2, ref3, v, vertex, vertexRefCountToZero;
      vertexRefCountToZero = 0;
      laterIndexIndices = 0;
      laterIndexVtoIMap = 0;
      for (k = 0, len = faces.length; k < len; k++) {
        face = faces[k];
        ref = face.v;
        for (l = 0, len1 = ref.length; l < len1; l++) {
          vertex = ref[l];
          this.vertexReferenceCounts[vertex.toString()]--;
          if (this.vertexReferenceCounts[vertex.toString()] === 0) {
            vertexRefCountToZero++;
            index = this.vertexToIndexMap[vertex.toString()];
            this.vertices.splice(index * this.stride, this.stride);
            delete this.vertexToIndexMap[vertex.toString()];
            ref1 = this.indices;
            for (i = m = 0, len2 = ref1.length; m < len2; i = ++m) {
              laterIndex = ref1[i];
              if (!(laterIndex > index)) {
                continue;
              }
              this.indices[i]--;
              laterIndexIndices++;
            }
            ref2 = this.vertexToIndexMap;
            for (v in ref2) {
              laterIndex = ref2[v];
              if (!(laterIndex > index)) {
                continue;
              }
              this.vertexToIndexMap[v]--;
              laterIndexVtoIMap++;
            }
          }
        }
        location = this.faceToIndexLocationMap[face.toString()];
        this.indices.splice(location, 3);
        delete this.faceToIndexLocationMap[face.toString()];
        ref3 = this.faceToIndexLocationMap;
        for (otherFace in ref3) {
          otherLocation = ref3[otherFace];
          if (otherLocation > location) {
            this.faceToIndexLocationMap[otherFace] = otherLocation - 3;
          }
        }
      }
      return console.log("vertices: " + this.vertices.length + ", indices: " + this.indices.length + ", faces: " + faces.length + ", ref zeros: " + vertexRefCountToZero + ", laterIndices: " + laterIndexIndices + ", laterVtoIMap: " + laterIndexVtoIMap);
    };

    Model.prototype.vertexExists = function(v) {
      return this.vertexToIndexMap[v.toString()] != null;
    };

    Model.prototype.getBary = function(face, i) {
      var existingBarys, j, v;
      if (face.b[i] != null) {
        return face.b[i];
      }
      existingBarys = (function() {
        var k, len, ref, results1;
        ref = face.v;
        results1 = [];
        for (j = k = 0, len = ref.length; k < len; j = ++k) {
          v = ref[j];
          if (j !== i && this.vertexExists(v)) {
            results1.push(this.getExistingBary(v));
          }
        }
        return results1;
      }).call(this);
      switch (false) {
        case existingBarys.length !== 2:
          return Vector.nor(existingBarys[0], existingBarys[1]);
        case !(existingBarys.length < 2 && i === 0):
          return [1, 0, 0];
        case !(existingBarys.length < 2 && i === 1):
          return [0, 1, 0];
        case !(existingBarys.length < 2 && i === 2):
          return [0, 0, 1];
      }
    };

    Model.prototype.getExistingBary = function(v) {
      var i;
      i = this.vertexToIndexMap[v.toString()] * this.stride + 3;
      return this.vertices.slice(i, +(i + 2) + 1 || 9e9);
    };

    Model.prototype.buildModel = function() {
      var k, len, p, ref, s;
      this.arrayBuffer = this.makeArrayBuffer(this.vertices);
      s = this.bufferByteCounts[this.arrayBuffer];
      ref = this.pointers;
      for (k = 0, len = ref.length; k < len; k++) {
        p = ref[k];
        this.program.setAttribPointer(this.arrayBuffer, p.name, p.dim, this.stride * s, p.offset * s);
      }
      return this.indexBuffer = this.makeIndexBuffer(this.indices);
    };

    Model.prototype.makeArrayBuffer = function(bufferData) {
      var floatArray;
      if (this.arrayBuffer == null) {
        this.arrayBuffer = this.gl.createBuffer();
      }
      floatArray = new Float32Array(bufferData);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.arrayBuffer);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, floatArray, this.gl.STATIC_DRAW);
      this.bufferByteCounts[this.arrayBuffer] = floatArray.BYTES_PER_ELEMENT;
      return this.arrayBuffer;
    };

    Model.prototype.makeIndexBuffer = function(bufferData) {
      var uIntArray;
      if (this.indexBuffer == null) {
        this.indexBuffer = this.gl.createBuffer();
      }
      uIntArray = new Uint16Array(bufferData);
      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
      this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, uIntArray, this.gl.STATIC_DRAW);
      this.bufferByteCounts[this.indexBuffer] = uIntArray.BYTES_PER_ELEMENT;
      return this.indexBuffer;
    };

    Model.prototype.setupTexture = function(url, sampler, i) {
      var img;
      img = new Image();
      img.onload = (function(_this) {
        return function() {
          var texture;
          texture = _this.gl.createTexture();
          _this.gl.pixelStorei(_this.gl.UNPACK_FLIP_Y_WEBGL, 1);
          _this.gl.activeTexture(_this.gl["TEXTURE" + i]);
          _this.gl.bindTexture(_this.gl.TEXTURE_2D, texture);
          _this.gl.texParameteri(_this.gl.TEXTURE_2D, _this.gl.TEXTURE_MIN_FILTER, _this.gl.LINEAR);
          _this.gl.texImage2D(_this.gl.TEXTURE_2D, 0, _this.gl.RGB, _this.gl.RGB, _this.gl.UNSIGNED_BYTE, img);
          return _this.program.setUniform(sampler, i);
        };
      })(this);
      return img.src = url;
    };

    Model.prototype.addModifier = function(label, f) {
      return this.modifiers[label] = f;
    };

    Model.prototype.removeModifier = function(label) {
      return delete this.modifiers[label];
    };

    Model.prototype.applyModifiers = function() {
      var f, i, k, label, mod, ref, ref1, ref2, v;
      ref = this.modifiers;
      for (label in ref) {
        f = ref[label];
        for (i = k = 0, ref1 = this.vertices.length - 1, ref2 = this.stride; ref2 > 0 ? k <= ref1 : k >= ref1; i = k += ref2) {
          v = new Vector(this.vertices.slice(i, +(i + 2) + 1 || 9e9));
          mod = f(v).elements();
          this.vertices.splice(i, 3, mod[0], mod[1], mod[2]);
        }
      }
      return this.buildModel();
    };

    return Model;

  })();

}).call(this);

//# sourceMappingURL=model.js.map
