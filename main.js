// Generated by CoffeeScript 1.10.0
(function() {
  var setCanvasSize;

  $(function() {
    var canvas, diffX, diffY, dragging, engine, featurePoints, gl, i, octaFaces, octahedron, plateElevations, program, rX, rY, setSize, x, y, z;
    Math.seedrandom('goldberg');
    canvas = setCanvasSize();
    gl = canvas.getContext('webgl');
    gl.enable(gl.DEPTH_TEST);
    gl.enable(gl.CULL_FACE);
    gl.clearColor(0.1, 0.0, 0.5, 1.0);
    gl.getExtension('OES_standard_derivatives');
    program = new ShaderProgram(gl);
    program.addShader(gl.VERTEX_SHADER, '#define M_PI 3.1415926535897932384626433832795\nattribute vec4 a_Position;\nattribute vec3 a_Bary;\nvarying vec3 v_Bary;\nvarying highp vec4 v_Pos;\nuniform mediump mat4 u_ModelMatrix;\nuniform mediump mat4 u_ViewMatrix;\nuniform mediump mat4 u_ProjMatrix;\nuniform mediump vec3 featurePoints[20];\nuniform float plateElevations[20];\n\nint nearest(vec4 pos) {\n  int near_idx = 0;\n  float d = 1000.0;\n  for (int i = 0; i < 20; i++) {\n    float current = acos(dot(vec3(pos.xyz),featurePoints[i])) / M_PI * 3.0;\n    if (current < d) {\n        d = current;\n        near_idx = i;\n    }\n  }\n  return near_idx;\n}\n\nvoid main() {\n  //int i = nearest(a_Position);\n  //vec4 pos = vec4(a_Position.xyz * plateElevations[i], 1.0);\n  gl_Position = u_ProjMatrix * u_ViewMatrix * u_ModelMatrix * a_Position;\n  v_Bary = a_Bary;\n  v_Pos = a_Position;\n}');
    program.addShader(gl.FRAGMENT_SHADER, '#extension GL_OES_standard_derivatives : enable\n#define M_PI 3.1415926535897932384626433832795\nprecision mediump float;\nvarying vec3 v_Bary;\nvarying highp vec4 v_Pos;\nuniform mediump vec3 featurePoints[20];\n\nfloat edgeFactor(){\n  vec3 d = fwidth(v_Bary);\n  vec3 a3 = smoothstep(vec3(0.0), 1.25*d, v_Bary);\n  return min(min(a3.x, a3.y), a3.z);\n}\n\nvec2 nearest(vec4 pos) {\n  float d = 1000.0;\n  float d2 = 1000.0;\n  for (int i = 0; i < 20; i++) {\n    float current = acos(dot(vec3(pos.xyz),featurePoints[i])) / M_PI * 3.0;\n    if (current < d) {\n        d2 = d;\n        d = current;\n    } else if (current < d2) {\n        d2 = current;\n    }\n  }\n  return vec2(d,d2);\n}\n\nvoid main() {\n  //vec2 near = nearest(v_Pos);\n  //float c = min(1.0,near[1] - near[0]);\n  vec3 faceColor = vec3(0.8,0.8,0.8);\n  vec3 wireColor = vec3(0, 0, 0);\n  gl_FragColor = vec4(mix(wireColor, faceColor, edgeFactor()),1);\n  //gl_FragColor = vec4(faceColor,1.0);\n}');
    featurePoints = (function() {
      var j, results;
      results = [];
      for (i = j = 0; j <= 19; i = ++j) {
        results.push(Vector.random().elements());
      }
      return results;
    })();
    featurePoints = [].concat.apply([], featurePoints);
    plateElevations = (function() {
      var j, results;
      results = [];
      for (i = j = 0; j <= 19; i = ++j) {
        results.push(1 + Math.random() * 0.025);
      }
      return results;
    })();
    program.activate();
    program.setUniformVectorArray('featurePoints', featurePoints);
    program.setUniformArray('plateElevations', plateElevations);
    setSize = function() {
      var proj;
      gl.viewport(0, 0, canvas.width, canvas.height);
      proj = Matrix.perspective(90, canvas.width / canvas.height, 0.1, 20);
      return program.setUniformMatrix('u_ProjMatrix', proj.array());
    };
    setSize();
    $(window).resize(function() {
      setCanvasSize();
      return setSize();
    });
    octaFaces = [new Face(new Vector([0, 1, 0]), new Vector([0, 0, 1]), new Vector([1, 0, 0])), new Face(new Vector([0, 1, 0]), new Vector([-1, 0, 0]), new Vector([0, 0, 1])), new Face(new Vector([0, 1, 0]), new Vector([0, 0, -1]), new Vector([-1, 0, 0])), new Face(new Vector([0, 1, 0]), new Vector([1, 0, 0]), new Vector([0, 0, -1])), new Face(new Vector([0, -1, 0]), new Vector([1, 0, 0]), new Vector([0, 0, 1])), new Face(new Vector([0, -1, 0]), new Vector([0, 0, 1]), new Vector([-1, 0, 0])), new Face(new Vector([0, -1, 0]), new Vector([-1, 0, 0]), new Vector([0, 0, -1])), new Face(new Vector([0, -1, 0]), new Vector([0, 0, -1]), new Vector([1, 0, 0]))];
    octahedron = new Model(gl, program, octaFaces);
    diffX = 0;
    diffY = 0;
    dragging = false;
    x = 0;
    y = 0;
    rX = 0;
    rY = 0;
    z = 7;
    octahedron.animate = function(elapsed) {
      var c, centroid, model, proj, pvm, view;
      rX += (dragging != null) && dragging ? diffX : 0;
      rY += (dragging != null) && dragging ? diffY : 0;
      model = Matrix.rotation(-rX * 0.4 % 360, 0, 1, 0).multiply(Matrix.rotation(-rY * 0.4 % 360, 1, 0, 0));
      program.setUniformMatrix('u_ModelMatrix', model.array());
      view = Matrix.lookAt([0, 0, z], [0, 0, 0], [0, 1, 0]);
      program.setUniformMatrix('u_ViewMatrix', view.array());
      proj = Matrix.perspective(90, canvas.width / canvas.height, 0.1, 20);
      pvm = proj.multiply(view).multiply(model);
      c = new Vector([0, 0, z]);
      octahedron.detail(model, c);
      return centroid = model.multiply(octahedron.faces[0].centroid);
    };
    octahedron.draw = function() {
      return gl.drawElements(gl.TRIANGLES, octahedron.indices.length, gl.UNSIGNED_SHORT, 0);
    };
    engine = new Engine(gl);
    engine.addModel(octahedron);
    engine.start();
    $("#gl").mousedown(function(e) {
      x = e.pageX;
      y = e.pageY;
      return dragging = true;
    });
    $("#gl").mousemove(function(e) {
      diffX = x != null ? x - e.pageX : 0;
      diffY = y != null ? y - e.pageY : 0;
      x = e.pageX;
      return y = e.pageY;
    });
    $("#gl").mouseup(function(e) {
      return dragging = false;
    });
    return $('#gl').mousewheel(function(e) {
      var delta;
      delta = Math.min(0.04, (z - 1) * 0.1);
      return z += e.deltaY * delta;
    });
  });

  setCanvasSize = function() {
    var canvas, devicePixelRatio, overdraw, scale;
    canvas = document.getElementById('gl');
    devicePixelRatio = window.devicePixelRatio || 1;
    overdraw = 1;
    scale = devicePixelRatio * overdraw;
    canvas.width = window.innerWidth * scale;
    canvas.height = window.innerHeight * scale;
    canvas.style.width = window.innerWidth + "px";
    canvas.style.height = window.innerHeight + "px";
    return canvas;
  };

}).call(this);

//# sourceMappingURL=main.js.map
